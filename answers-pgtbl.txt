Q: Explain the output of vmprint in terms of Fig 3-4 from the text. What does page 0 contain? What is in page 2? When running in user mode, could the process read/write the memory mapped by page 1?
A:
根据 exec() 函数和 xv6 指导书可以看到如下代码会为 ELF 文件的段(segment)分配内存并进行加载, 因此推测该内容即为 page 0 所存放的.
在加载 ELF 段后会分配两个 page, 对应 page1 和 page2, 而 page 2 用作用户的栈.
进一步可以看出, page0 应该主要是应用程序的代码段和数据段; 而 page2 即对应着用户栈; 中间的 page1 应该是 guard page, 无物理地址实际映射, 用于溢出检测.
Q: Explain why the third test srcva + len < srcva is necessary in copyin_new(): give values for srcva and len for which the first two test fail (i.e., they will not cause to return -1) but for which the third one is true (resulting in returning -1).
A: 三个 return -1 的条件分别为 srcva >= p->sz, srcva+len >= p->sz 和 srcva+len < srcva. 很显然, 此处第三个条件主要是进行溢出检测, 防止无符号整数上溢. 由于 srcva 和 len 均为 uint64 类型的变量, 当 srcva 小于 p->sz 但是 len 为一个极大的数时, 如 0xffff...ffff(即对应 -1), 由于无符号整数溢出便可以满足 srcva+len < p->sz 这一条件, 但实际上复制了大量内存. 但通过 srcva+len < srcva 这一判断条件能够检测出溢出.